<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>WebXR: SBS + Single HUD (1/5 FOV, fixed corner)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
    <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.173.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.173.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        let scene, camera, renderer;
        let planeLeft = null, planeRight = null;
        let sbsTexture = null;   // the loaded side-by-side texture

        const DISTANCE = 20;      // how far from each eye to place the main SBS planes
        const HUD_DISTANCE = 10; // how far in front of the camera we place the HUD plane

        let hudPlane, hudTexture, hudCtx;
        let hudCreated = false;  // so we only create/attach the HUD once

        // Temp re-usable objects
        const tmpPos = new THREE.Vector3();
        const tmpQuat = new THREE.Quaternion();

        init();
        animate();

        /** Initialize scene, camera, renderer, etc. */
        function init() {
            scene = new THREE.Scene();

            // Main camera used outside VR. In immersive mode, an ArrayCamera is used under the hood.
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            // So colors don’t look washed out
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.NoToneMapping;

            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // Load SBS texture
            const loader = new THREE.TextureLoader();
            loader.load('assets/Seagull_2x1.jpg', (tex) => {
                tex.encoding = THREE.sRGBEncoding;
                sbsTexture = tex;
                console.log('Loaded SBS texture:', tex.image.width, 'x', tex.image.height);
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /** Main XR animation loop. */
        function animate() {
            renderer.setAnimationLoop(() => {
                const xrCam = renderer.xr.getCamera(camera);

                // If in VR (ArrayCamera) and we have our texture loaded:
                if (sbsTexture && xrCam.isArrayCamera && xrCam.cameras.length === 2) {

                    // Create SBS planes if not done yet
                    if (!planeLeft || !planeRight) {
                        createPlanes();
                    }

                    // Sub-cameras
                    const leftCam = xrCam.cameras[0];
                    const rightCam = xrCam.cameras[1];

                    // Create/attach the HUD plane once we can parse left-cam’s FOV
                    if (!hudCreated) {
                        createHUDWithFOV(leftCam);
                        hudCreated = true;
                    }

                    // Position the SBS planes for each eye
                    fitAndPositionPlane(planeLeft, leftCam);
                    fitAndPositionPlane(planeRight, rightCam);

                    // Each eye sees only its plane
                    leftCam.layers.enable(1);
                    rightCam.layers.enable(2);

                    // Update HUD text
                    updateHUD(leftCam, rightCam);
                }

                renderer.render(scene, camera);
            });
        }

        /* ----------------  SBS PLANES  ---------------- */

        /** Create two planes, each half of the SBS texture. */
        function createPlanes() {
            console.log('Creating SBS planes...');
            const texLeft = sbsTexture.clone();
            texLeft.encoding = THREE.sRGBEncoding;
            texLeft.offset.set(0, 0);
            texLeft.repeat.set(0.5, 1);

            const texRight = sbsTexture.clone();
            texRight.encoding = THREE.sRGBEncoding;
            texRight.offset.set(0.5, 0);
            texRight.repeat.set(0.5, 1);

            const matLeft = new THREE.MeshBasicMaterial({ map: texLeft });
            const matRight = new THREE.MeshBasicMaterial({ map: texRight });

            // 1x1 geometry, to be scaled each frame to fit the eye's FOV
            const planeGeom = new THREE.PlaneGeometry(1, 1);

            planeLeft = new THREE.Mesh(planeGeom, matLeft);
            planeLeft.layers.set(1); // left eye only
            scene.add(planeLeft);

            planeRight = new THREE.Mesh(planeGeom, matRight);
            planeRight.layers.set(2); // right eye only
            scene.add(planeRight);
        }

        /**
         * fitAndPositionPlane(plane, subCam):
         * 1) Copy sub-cam pos/orient
         * 2) Parse sub-cam FOV
         * 3) Scale so it won't crop at DISTANCE
         * 4) Move plane DISTANCE forward
         */
        function fitAndPositionPlane(plane, subCam) {
            subCam.getWorldPosition(tmpPos);
            subCam.getWorldQuaternion(tmpQuat);

            plane.position.copy(tmpPos);
            plane.quaternion.copy(tmpQuat);

            // Derive sub-cam FOV & aspect from its projectionMatrix
            const { fov, aspect } = parseSubCamFov(subCam);

            // If your image is 2:1, each half is (imgW/(2*imgH))
            const imgW = sbsTexture.image.naturalWidth;
            const imgH = sbsTexture.image.naturalHeight;
            const halfAspect = imgW / (2 * imgH);

            const { planeWidth, planeHeight } = fitPlaneInFov(halfAspect, fov, aspect, DISTANCE);
            plane.scale.set(planeWidth, planeHeight, 1);

            plane.translateZ(-DISTANCE);
        }

        /** parseSubCamFov(subCam): get vertical FOV & approximate aspect from sub-cam. */
        function parseSubCamFov(subCam) {
            const m = subCam.projectionMatrix.elements;
            // For a symmetric perspective: m[5] = 1 / tan(vFOV/2)
            const vFov = 2 * Math.atan(1 / m[5]);
            const aspect = m[5] / m[0];
            return { fov: vFov, aspect };
        }

        /** fitPlaneInFov(planeAspect, vFOV, camAspect, dist) => planeWidth/planeHeight w/o cropping. */
        function fitPlaneInFov(planeAspect, vFOV, camAspect, dist) {
            // Fit vertically
            let planeHeight = 2 * dist * Math.tan(vFOV / 2);
            let planeWidth = planeHeight * planeAspect;

            // Check horizontal
            const hFov = 2 * Math.atan(camAspect * Math.tan(vFOV / 2));
            const horizontalMax = 2 * dist * Math.tan(hFov / 2);

            if (planeWidth > horizontalMax) {
                const scale = horizontalMax / planeWidth;
                planeWidth *= scale;
                planeHeight *= scale;
            }
            return { planeWidth, planeHeight };
        }

        /* ----------------  HUD  ---------------- */

        /**
         * createHUDWithFOV(referenceCam):
         *   1) Parse leftCam's horizontal FOV at `HUD_DISTANCE`,
         *   2) Make the HUD plane geometry sized at (1/5 of that view width) x half that,
         *   3) Parent it to the main camera so it doesn't move in your view,
         *   4) Position it in the top-left corner of your local camera space.
         */
        function createHUDWithFOV(referenceCam) {
            console.log('Creating HUD using left sub-cam FOV at distance', HUD_DISTANCE);

            // 1) Compute horizontal FOV from the left sub-cam
            const { fov: vFOV, aspect } = parseSubCamFov(referenceCam); // vertical FOV in radians
            const hFOV = 2 * Math.atan(aspect * Math.tan(vFOV / 2));   // horizontal FOV in radians
            console.log('Left sub-cam FOV:', hFOV * 180 / Math.PI, 'degrees');
            console.log('Left sub-cam aspect:', aspect);

            // At distance = HUD_DISTANCE, the full width of the left eye’s view is:
            const viewWidth = 2 * HUD_DISTANCE * Math.tan(hFOV / 2);
            const viewHeight = 2 * HUD_DISTANCE * Math.tan(vFOV / 2);
            console.log('Left sub-cam view width:', viewWidth, 'height:', viewHeight);

            // We'll make our HUD plane 1/5 of that width, and half as tall
            const hudW = viewWidth / 5;
            const hudH = hudW / 2;

            // 2) Build the canvas + texture
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            hudCtx = canvas.getContext('2d');

            hudTexture = new THREE.CanvasTexture(canvas);
            hudTexture.encoding = THREE.sRGBEncoding;

            const hudMat = new THREE.MeshBasicMaterial({
                map: hudTexture,
                transparent: true
            });

            // 3) Create a plane geometry with that size
            const hudGeom = new THREE.PlaneGeometry(hudW, hudH);
            hudPlane = new THREE.Mesh(hudGeom, hudMat);

            // 4) Parent it to the camera so it doesn't move if the XR camera moves around the room
            camera.add(hudPlane);

            // 5) Position it in local camera space so it appears in the top-left corner
            //    We'll move it forward by -HUD_DISTANCE, left, and up:
            //    The plane is center-anchored, so if we want top-left corner in view,
            //    shift half of its width left, half of its height up.
            hudPlane.position.set(- (viewWidth / 2) + (hudW / 2),
                viewHeight/2 - (hudH / 2), // or we can use vFOV to get top, but we do a rough approximation
                - HUD_DISTANCE);
            console.log('HUD plane positioned at', hudPlane.position);
        }

        /**
         * updateHUD(leftCam, rightCam):
         *   Draw each eye’s position onto the HUD plane. Called every frame.
         */
        function updateHUD(leftCam, rightCam) {
            if (!hudCtx || !hudTexture) return;

            hudCtx.clearRect(0, 0, hudCtx.canvas.width, hudCtx.canvas.height);

            // Semi-transparent background
            hudCtx.fillStyle = 'rgba(0,0,0,0.5)';
            hudCtx.fillRect(0, 0, hudCtx.canvas.width, hudCtx.canvas.height);

            hudCtx.fillStyle = '#fff';
            hudCtx.font = '20px sans-serif';
            hudCtx.fillText('Eye Positions', 10, 26);

            // Grab each eye’s world position
            const leftPos = new THREE.Vector3();
            const rightPos = new THREE.Vector3();
            leftCam.getWorldPosition(leftPos);
            rightCam.getWorldPosition(rightPos);

            const lx = leftPos.x.toFixed(2), ly = leftPos.y.toFixed(2), lz = leftPos.z.toFixed(2);
            const rx = rightPos.x.toFixed(2), ry = rightPos.y.toFixed(2), rz = rightPos.z.toFixed(2);

            hudCtx.fillText(`Left:  (${lx}, ${ly}, ${lz})`, 10, 60);
            hudCtx.fillText(`Right: (${rx}, ${ry}, ${rz})`, 10, 90);

            hudTexture.needsUpdate = true;
        }
    </script>
</body>

</html>